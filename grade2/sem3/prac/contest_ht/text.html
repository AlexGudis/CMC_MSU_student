<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<title>Problem statement</title>
</head>
<body>
<h3>Problem ht09-4: ht09-4</h3>
<p/>

<p>Реализуйте функции</p>

<pre><code>char *b64u_encode(const uint8_t *data, size_t size);
bool b64u_decode(const char *str, uint8_t **p_data, size_t *p_size);</code></pre>

<p>Функции выполняют кодирование и декодирование массива байт
в формат URL-encoded unpadded Base64
(см. <a href="https://en.wikipedia.org/wiki/Base64">URL-encoded unpadded base64</a>, раздел "Variants summary table" в строке base64url).</p>

<p>Функция <code>b64u_encode</code> принимает в качестве параметров
указатель <code>data</code> на массив байт размера <code>size</code>.
Функция возвращает указатель на строку, выделенную в куче.
Строка должна содержать закодированное представление
входного массива байт. В закодированной строке
не допускаются никакие посторонние символы, кроме кодирующих
(то есть пробельные символы не допускаются).
В случае ошибки выделения памяти функция возвращает <code>NULL</code>.</p>

<p>Функция <code>b64u_decode</code> принимает в качестве
входного параметра <code>str</code> закодированные данные
в си-строке. Строка может содержать пробельные символы
(см. функцию <code>isspace</code>), которые должны игнорироваться.
Функция возвращает <code>false</code>, если входная строка
содержит некорректные данные. Функция возвращает <code>true</code>,
если входные данные корректны. В этом случае по указателю <code>p_data</code>
записывается адрес начала буфера с декодированными данными,
а по указателю <code>p_size</code> &mdash; размер
декодированных данных. В конец декодированных данных, то есть
по индексу <code>*p_size</code>, обязательно записывается нулевой байт.
Память выделяется в куче.</p>

<p>Вы можете адаптировать какую-либо из существующих реализаций
кодирования base64 при условии ссылки на первоначальную реализацию.</p>

    
</body>
</html>

